

							GIT
	
	GIT индексирует файл в точности в том состоянии в котором он находиться когда вы выполнили последний раз
	команду (git add) и если выполнить команду commit то файл добавиться в том состоянии в котором он был
	когда мы последний раз использовали команду (git add)
	Если изменили файл после выполнения (git add) то нужно снова выполнить эту команду что-бы заново
	ПРОИНДЕКСИРОВАТЬ изменней файл ( что-бы если выполнить команду commet мы добовили файл с последними изменениями)
							
							cd Z:/loftblog - выделяет даную папку потом применяем команду нижу
							git init       - эта команда создает GIT в данной папке для репозитория
							git add .      - . означает ИНДЕКСИРОВАТЬ все что находиться в папке loftblog
							git add new.html - ИНДЕКСИРОВАТЬ определенную папку
							git status     - показывает состояние Репозитория в папке loftblog
							git commit -m "first commit"  - СОЗДАЕМ (Снимок проиндексированных файлов рабочей директории) комит из нашего файла (или нескольких файлов)
					Как правило в комите пишем название изменений которые мы внесли ( чты-бы при выкладывании в интернет по комиту проще было разобраться)
							git log --graph --all               - построит псевдо графи дерево нашиъ комитов
							git log --graph --all --decorate    - (decorate) раскрасит цветами 
							git log --graph --all --decorate --online - (online зделает в одну строку)
							git merge new_style - сливает указаную ветку (new_style) в мастер 
											(origin master - любое имя пишем)
							git remote add origin https://github.com/bogdandvinin/capons.git - команда указаный репозиторий на github ( потом высветиться указать логин и пароль на github)
							git push -u origin master - а теперь выполняем команду по заливке нашего файла в указаный репозиторий выше
							
							git clone https://github.com/jquery/jquery.git - клонируем к себе в папку из которой установили репозиторий ( правой кнопкой по попке и запускаем GitBush)
							
							git checkout -b style - создаем ветку с названием (style)
							git checkout master  - вернуться в ветку мастер
							git checkout style - style название ветки


							----Создание новой ветки

							https://github.com/Kunena/Kunena-Forum/wiki/Create-a-new-branch-with-git-and-manage-branches - создание новой ветки
							
							
							    git branch - покажет список всех веток и активную ветку в данный момент
                                                         -------ЗАЛИВАЕМ ИНФУ НА НОВУЮ ВЕТКУ В УЖЕ СУЩЕСТВУЮЩЕМ РЕПОЗИТОРИИ
								git branch new_feature
								git checkout new_feature          - выбираем новосозданую ветку для комитов
								git add .                         - добавляем изменения
								git commit -m "new_branch_commit" - создаем новый комит
								git push origin new_feature - заливаем на новую ветку новый комит
								
								git checkout master - выбираем ветку масте - возвращаемся для работы к ней
								
								--СЛИЯНИЕ ВЕТОК В ОДНУ
								git commit -a # делаем коммит всех изменений в new_feature
								git checkout master # переключаемся на master
								git merge new_feature # мерджим ветку new_feature
								git push origin master   - выполняем команду по слиянию ведок на сервере
							 	--И у нас появляеться на мастере новый комит с соедененой веткой
							
							-----
							Если мы правим код с нескольких компьютеров, то перед началом работы не забываем «накатить» в локальный репозиторий последнюю версию кода:
								git pull origin


							
							Пример создания GIT в ипределенной папке
					
cd Z:/loftblog
git init	                 - создает скрытую папку GIT в loftblog
git add.                     - ИНДЕКСИРУЕТ все что в папке loftblog						
git commit -m "first commit" - СОЗДАЕМ комит из нашего файла (или нескольких файлов)


							
							
1. Каждый файл может находиться в одном из 2-х состояний 
				мастер - это главная ветка которую мы создали для GIT в нашем случае ( cd Z:/loftblog) а потом сделали (git init) и в этой папке создался GIT для репозиториев
				1 - Файлы отслеживаемые 
				Что-бы сделать отслеживаемыми нужно добавить файлы нужно написать команду 
				
				git status - помогает показать в каком состоянии находяться наши репозитории ( файлы которые лежат рядом с папкой GIT)
				
				2 - Файле не отслеживаемые
				
				
				
				
				
ПРИМЕР Рабочего процесса с репозиторием -------------------------
	cd/ c:/users/Ира/Desktop/bootstrap   - указываем путь к файлу с которым будем работать
	
	git init                             - делаем указаное место рабочим с GIT

	git add .                            - индексируем все файлы в папке 

	git commit -m "first commit"         - Создаем комит с названием "first commit"

		дальше если мы вносим какие либо изменения в файл и сохраняем его то 
	
	git add .                            - индексируем изменения сохраненного нового файла	
	
	git commit -m "Second commit"        - создаем второй комит нашего вновь сохраненного файла с изменениями "Second commit"

		И ТОГО У НАС ЕСТЬ 2 Комита с двумя версиями нашего одного файла до и после изменения
		
Теперь можно заливать на удаленный РЕПОЗИТОРИЙ тоесть https://github.com/
И на этом сайте создаем репозиторий на который зальем наши файлы когда репозиторий создан
открываеться меню из строки (…or push an existing) копируем путь к нашему созданому репозитори на сайте и команду для єтого пути 
путь пишеться автоматически в єтом окне
	git remote add origin https://github.com/bogdandvinin/capons.git
    git push -u origin master
	(вот єти 2 строки) вставляю в командное окно GIT
	потом появиться окно с логином и паролем на сайт GIT мы вводим и все заливаеться
	

	------------------------------------------
	
 Кланировать репозиторий из сайта GIThub.com себе на компьютер 
 1) использовать https - адрест файла  
 Это самый простой способ - копируем удрес который высветиться на сайте в закладке HTTPS файла который мы 
 нашли на GIT
 Создаем папку на рабочем столе куда мы будем заливать файлы с сайта потом 
 Правой кнопкой по папке и нажемаем запустить GITBUSH
 с командной строке пишем 
 git clone https://github.com/jquery/jquery.git - и начинает клонировать файл с github.com в мою папку
 
 и потом файл можно запускать на компьютере и работать с ним
 
 2) SSH
 3) Subversion





-------------------ПРОСТО КОМАНДЫ GIT
 
 
 Создать новый репозиторий:
git init project-name

Если вы планируете клонировать его по ssh с удаленной машины, также скажите:
git config --bool core.bare true

… иначе при git push вы будете получать странные ошибки вроде:
Refusing to update checked out branch: refs/heads/master
By default, updating the current branch in a non-bare repository
is denied, because it will make the index and work tree inconsistent
with what you pushed, and will require 'git reset --hard' to match
the work tree to HEAD.

Клонировать репозиторий с удаленной машины:
git clone git@bitbucket.org:afiskon/hs-textgen.git

Если хотим пушить один код в несколько репозиториев:
git remote add remotename git@gitlab.example.ru:repo.git

Добавить файл в репозиторий:
git add text.txt

Удалить файл:
git rm text.txt

Текущее состояние репозитория (изменения, неразрешенные конфликты и тп):
git status

Сделать коммит:
git commit -a -m "Commit description"

Сделать коммит, введя его описание с помощью $EDITOR:
git commit -a

Замерджить все ветки локального репозитория на удаленный репозиторий (аналогично вместо origin можно указать и remotename, см выше):
git push origin

Аналогично предыдущему, но делается пуш только ветки master:
git push origin master

Запушить текущую ветку, не вводя целиком ее название:
git push origin HEAD

Замерджить все ветки с удаленного репозитория:
git pull origin

Аналогично предыдущему, но накатывается только ветка master:
git pull origin master

Накатить текущую ветку, не вводя ее длинное имя:
git pull origin HEAD

Скачать все ветки с origin, но не мерджить их в локальный репозиторий:
git fetch origin

Аналогично предыдущему, но только для одной заданной ветки:
git fetch origin master

Начать работать с веткой some_branch (уже существующей):
git checkout -b some_branch origin/some_branch

Создать новый бранч (ответвится от текущего):
git branch some_branch

Переключиться на другую ветку (из тех, с которыми уже работаем):
git checkout some_branch

Получаем список веток, с которыми работаем:
git branch # звездочкой отмечена текущая ветвь

Просмотреть все существующие ветви:
git branch -a # | grep something

Замерджить some_branch в текущую ветку:
git merge some_branch

Удалить бранч (после мерджа):
git branch -d some_branch

Просто удалить бранч (тупиковая ветвь):
git branch -D some_branch

История изменений:
git log

История изменений в обратном порядке:
git log --reverse

История конкретного файла:
git log file.txt

Аналогично предыдущему, но с просмотром сделанных изменений:
git log -p file.txt

История с именами файлов и псевдографическим изображением бранчей:
git log --stat --graph

Изменения, сделанные в заданном коммите:
git show d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4

Посмотреть, кем в последний раз правилась каждая строка файла:
git blame file.txt

Удалить бранч из репозитория на сервере:
git push origin :branch-name

Откатиться к конкретному коммиту (хэш смотрим в «git log»):
git reset --hard d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4

Аналогично предыдущему, но файлы на диске остаются без изменений:
git reset --soft d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4

Попытаться обратить заданный commit (но чаще используется branch/reset + merge):
git revert d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4

Просмотр изменений (суммарных, а не всех по очереди, как в «git log»):
git diff # подробности см в "git diff --help"

Используем vimdiff в качестве программы для разрешения конфликтов (mergetool) по умолчанию:
git config --global merge.tool vimdiff

Отключаем диалог «какой mergetool вы хотели бы использовать»:
git config --global mergetool.prompt false

Разрешение конфликтов (когда оные возникают в результате мерджа):
git mergetool

Создание тэга:
git tag some_tag # за тэгом можно указать хэш коммита

Удаление untracked files:
git clean -f

«Упаковка» репозитория для увеличения скорости работы с ним:
git gc
 
 
 




 