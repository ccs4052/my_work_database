--------------------------------------ФУНКЦИИ ДЛЯ РАБОТЫ С КЛАССАМИ 

		get_class_methods() -  возвращает массив имен методов класса с заданным именем
		
		get_class_vars() - возвращает массив имен атрибутов класса с заданным именем (Возвращает все переменные класса). 
		
		get_object_vars() - возвращает ассоциативный массив с информацией обо всех атрибутах объекта с заданным именем (все переменные и значения возвращает).
		
		method_exists() проверяет, поддерживается ли объектом метод с заданным именем. Если метод поддерживается, функция возвращает TRUE, в противном случае возвращается FALSE.
		
			пример 
			$car = new Land;
			if (method_exists($car, "setfourWheelDrive")) :
			print "This car is equipped with 4-wheel drive";
			endif;
		
		get_class() - возвращает имя класса, к которому относится объект с заданным именем
				$car = new Land;
				$class_a = get_class($car);
				
		get_parent_class() возвращает имя родительского класса (если он есть) для объекта с заданным именем.
		
		get_declared_classes() возвращает массив с именами всех определенных классов.
		

----------------------------------------------------------------------



----------------------------КЛАССЫ   (это расширенные функции своего рода + все внутри появляеться в глобальной зоне видимости становиться супер глоб массивом)
----------------------------
----------------------------
Класс - это каркас для объекта. Это кусок кода, который определяет:
    Типы данных, которые будут содержать созданные объекты класса
    Функции, которые будут содержать эти объекты.
	Когда вы создаете приложение на ООП, вы обычно будете создавать несколько классов, которые будут представлять различные типы сущностей вашего приложения. Например, для создания форума вы можете создать классы Forum, Topic, Post и Member.
-----
Объект - это переменная специального типа, которая создается через класс. Он содержит действительные данные и функции для манипулирования ими. Вы можете создавать сколько угодно объектов от одного единственного класса.
	Каждая функция объекта не зависит от другого объекта, даже если они созданы от одного и того же класса.
	Для сравнения с реальными сущностями:
    Класс - это каркас для автомобиля: он определяет, как автомобиль будет выглядеть и действовать, но это все же абстрактная сущность
    Объект - это настоящий автомобиль, созданный из каркаса: у него есть настоящие свойства (например, скорость) и поведение (например, ускорение или торможение).
	На заметку: Объект часто называют сущностью класса, а процесс создания объекта класса - реализацией.
-----
Переменные класса - Значения данных, которые хранятся в том или ином объекте, записываются в специальные переменные, называемые переменными класса. 
	Переменные класса тесно связаны с его объектом. Несмотря на то что все объекты класса имеют одни и те же переменные, их значения могут отличаться.
------
Методы - Функции, определяемые в классе и применяемые для объектов этого класса, называются методами. Они не во многом отличаются от обычных функций - вы можете передавать им значения, они могут содержать локальные переменные и возвращать значения.
	Однако, методы чаще работают с переменными объекта. К примеру, метод login() для авторизации пользователей в вашем форуме может устанавливать значение переменной класса loggedIn в true.
-------------

Объектно-ориентированное программирование основано на:

    Инкапсуляции;
    Полиморфизме;
    Наследовании.

	ИНКАПСУЛЯЦИЯ - это механизм, объединяющий данные и обрабатывающий их код как единое целое.
		Инкапсуляцией называется включение различных мелких элементов в более крупный объект, в результате чего программист работает непосредственно с этим объектом. 
		Это приводит к упрощению программы, поскольку из нее исключаются второстепенные детали.
		

	ПОЛИМОРФИЗМ позволяет использовать одни и те же имена для похожих, но технически разных задач. 
		Главным в полиморфизме является то, что он позволяет манипулировать объектами путем создания стандартных интерфейсов для схожих действий.
		Полиморфизм значительно облегчает написание сложных программ.
			
			пример ----
					<?php
					class A {
					// Выводит, функция какого класса была вызвана
					function Test() { echo "Test from A\n"; }
					// Тестовая функция — просто переадресует на Test()
					function Call() { Test(); }
					}
					class B extends A {
					// Функция Test() для класса B
					function Test() { echo "Test from B\n"; }	//функция call() унаследована из класса A и когда мы ее вызываем в классе B она будет вызывать функцию Test() класса B
					}											//ВОТ И ПОЛИМОРФИЗМ ФУНКЦИЯ с одним и тем же именем РАЗНЫЕ СВОЙСТВА
					$a=new A();
					$b=new B();
					?>
					
					$a->Call(); // выводит "Test from A"
					$b->Test(); // выводит "Test from B"
					$b->Call(); // Внимание! Выводит "Test from B"!			//функция call() д
		
		
		
	НАСЛЕДОВАНИЕ позволяет одному объекту приобретать свойства другого объекта, не путайте с копированием объектов. 
		При копировании создается точная копия объекта, а при наследовании точная копия дополняется уникальными свойствами, которые характерны только для производного объекта.
	
	
	




	Обычно класс несет в себе название того что он делает и храниться в файле с таким же именем 

	1) Создание класса
   class Member {
   }
	
	2)Создадим ОБЪЕКТ КЛАССА 
	$member = new Member();
	и еще один 
	$member2 = new Member();
	Хотя объекты и созданы от одного класса они не звисят друг от друга

	  Создадим переменные класса
	Есть 3 ИДЕНТИФИКАТОРА ДОСТУПА для переменных класса, которые можно добавлять в класс:
	-Открытые переменные класса (public): доступны - т.е. их можно прочитать и/или изменять - в любом месте скрипта, независимо от того, где находится этот код - внутри класса или за его пределами
	-Частные переменные класса (private): доступны только методам класса. Лучше всего делать переменные класса именно private, чтобы отделить объекты от остальной части кода.
	-Защищенные переменные класса (protected): доступны методам собственного класса, а также методам наследуемых классов (мы поговорим о наследовании позже).
	
	class ClassName {
		public $propertyName;
		private $propertyName;
		protected $propertyName;
	}
	
	3)Создадим переменную класса в классе member для хранения имени пользователя
	
	class member {
		public $username = "";  //пустая переменная значит что мы инициализировали переменную класса 
	}
	$member = new Member(); //создали объект класс Member 
	$member ->username = "Bogdan"; //задаем значение переменной класса
	// -> обращаемся через объект к переменной класса
	echo $member->username; // Bogdan
	
	СОЗДАНИЕ МЕТОДОВ КЛАССА - Создаються методы так-же как и обычные функции
	только с добавление одного из 3-х идентификаторов доступа public private protected
	4)
	
	Давайте попробуем добавить в наш класс некоторые методы и переменные класса:
    переменная класса private $loggedIn для идентификации пользователя, т.е. зашел он или нет,
    метод login(), который будет осуществлять вход на форум, устанавливая значение переменной класса $loggedIn в true,
    метод logout(), который будет осуществлять выход из форума, устанавливая значение переменной класса $loggedIn в false,
    метод isLoggedIn(), который будет возвращать значение переменной класса $loggedIn.
	
	 В контексте методов объекта специальная переменная $this ссылается на сам объект.
	 Используя $this в методе объекта, метод может получить доступ к любой переменной класса и методу объекта.
	<?php
		class Member {
			public $username =""; // (в реальном проэкте нада назначит переменнную privat а тут для илюстрации public)инициальзируем переменную (создаем ее с пустым значение)
			private $loggedIn = false;   //private можно вызывать только из методов данного класса
			public function login(){     //метод login
				$this->loggedIn = true; //вызываем переменную класса и придаем ей другое значение
				}
			public function logout(){   //метод logout
				$this->loggedIn = false; //вызываем переменную класса и даем ей другое значение
				}
			public function isLoggedIn(){  //метод isLoggedIn
				return $this->loggedIn;   //возвращает значение переменной LoggedIn
				}
			}
			// пример использования 
			$member = new Member(); 	//создаем объект класса
			$member->username = "Fred"; //вызываем переменную класса Member и придаем ей значени
														//($test()? "выведеться если TRUE":"выведеться FALS")	- пример выражения нижу ! если это $test() TRUE то первое выведет если FALSE то второе				
			echo $member->username . " is " . ( $member->isLoggedIn() ? "logged in" : "logged out" ) . "<br>";
			$member->login();            //вызываем метод Login (он передает в переменую LoggedIn - true)
			// вызываем метод(функцию) класса через объект ->login();
			echo $member->username . " is " . ( $member->isLoggedIn() ? "logged in" : "logged out" );
			$member->logout();           //вызываем метод logout() он передает false в переменную LoggedIn
			echo $member->username . " is " . ( $member->isLoggedIn() ? "logged in" : "logged out" );
			?>
			ОТВЕТ -
			Fred is logged out
			Fred is logged in
			Fred is logged out
			
	-----------------$this и метод __construct  (ГОСТЕВАЯ КНИГА)		
	
	Теперь приступим к конкретным примерам. Попробуем создать простейшую ГОСТЕВУЮ КНИГУ. 
	
		Первое, что сделаем, это определим части необходимой нам сущности. Этими частями будут имя посетителя, его email и собственно его сообщение. Приступим.

		<?
		class GuestBook
		{
			private $name;
			private $email;
			private $msg;
			
			public function __construct($name, $email, $msg)
			{
				$this->name = $name;
				$this->email = $email;
				$this->msg = $msg;
			}
		}
		?> 
		
		ПОЛЯ объявлены с модификатором доступа private, который означает, что с полями класса можно работать только методам этого же класса
		 МЫ ОБЪЯВИЛИ МЕТОД __construct($name, $email, $msg). Этот метод является конструктором класса. О конструкторах и деструкторах будет рассказано немного позже, сейчас же запомните, что конструкторы всегда автоматически выполняются первыми, до всех остальных методов класса, непосредственно сразу после выделения памяти под объект.
		 Деструкторы же выполняются последними, непосредственно перед уничтожением объекта.
		 $this означает ссылку на объект, для которого реализована та или иная конструкция
		 $this->name и $name - это две разные переменные.
		 
		 
		 Реализуем методы, которые вернут соответствующие значения.
		 
		   <?
			class GuestBook
			{
				private $name;
				private $email;
				private $msg;
				
				public function __construct($name, $email, $msg)
				{
					$this->name = $name;
					$this->email = $email;
					$this->msg = $msg;
				}
				
				public function getName()
				{
					return $this->name;
				}
				public function getEmail()
				{
					return $this->email;
				}
				public function getMsg()
				{
					return $this->msg;
				}
			}
			?> 
			
			-----МЕТОД __construct()
			PHP 5 позволяет объявлять методы-конструкторы. Классы, в которых объявлен метод-констуктор, будут вызывать этот метод при каждом создании нового объекта,
			так что это может оказаться полезным, чтобы, например, инициализировать какое-либо состояние объекта перед его использованием. 
			Конструктор, ранее совпадавший с названием класса, теперь необходимо объявлять как __construct(), что позволит легче перемещать классы в иерархиях.
			Конструкторы в классах-родителях не вызываются автоматически. Чтобы вызвать конструктор, объявленный в родительском классе, следует обратиться к методу parent::__construct(). 
			
			<?php
			class BaseClass {
				 function __construct() {
					 print "Конструктор класса BaseClass\n";
				 }
			}

			class SubClass extends BaseClass {
				 function __construct() {
					 parent::__construct();
					 print "Конструктор класса SubClass\n";
				 }
			}

			$obj = new BaseClass();
			$obj = new SubClass();
			?>
			------
			------МЕТОД __destructor() 
			когда освобождается последняя ссылка на объект, перед высвобождением памяти, занимаемой этим объектом, вызывается метод __destruct(), не принимающий параметров. 
			
			<?php
			class MyDestructableClass {
				 function __construct() {
					 print "Конструктор\n";
					 $this->name = "MyDestructableClass";
				 }

				 function __destruct() {
					 print "Уничтожается " . $this->name . "\n";
				 }
			}

			$obj = new MyDestructableClass();
			?>
			
			Для вызова деструктора, объявленном в классе-родителе, следует обратиться к методу parent::__destruct().
			
			
			
			
			----------------КЛОНИРОВАНИЕ Класса
			---------------------------------------------------------------------
			
			Создание копии объекта с абсолютно идентичными свойствами не всегда является приемлемым вариантом.
				Например, когда ваш объект содержит ссылку на какой-либо другой используемый объект и, когда вы создаёте копию ссылающегося объекта,
				вам нужно также создать новый экземпляр содержащегося объекта, так, чтобы копия объекта содержала собственный отдельный экземпляр содержащегося объекта. 
			
			Копия объекта создается с использованием вызова clone (который вызывает метод __clone() объекта, если это возможно). 
				Вы можете объявить метод __clone(), который будет вызван при клонировании объекта (после того, как все свойства будут скопированы из исходного объекта). 
			
			Когда программист запрашивает создание копии объекта, PHP 5 определит, был ли для этого объекта объявлен метод __clone() или нет. Если нет, будет вызван метод __clone(), объявленный по умолчанию, который скопирует все свойства объекта.
				Если метод __clone() был объявлен, создание копий свойств в копии объекта полностью возлагается на него.
				
			---ПРИМЕР	
			<?php
			class MyClass {
				 function __clone() {					//эта функция может называться полюбому она все равно будет клонирована
					 print "Объект был клонирован ";
				 }
			}
			$obj = new MyClass();
			$clone_test = clone $obj;					//clone КЛАССА  MyClass
														//$clone_test теперь обладает всеми свойствами и методами класса MyClass
			?>
			
			
			
			
			--------------------------------КОНСТАНТЫ КЛАССА
			--------------------------------
			Разница между КОНСТАНТОЙ а ПЕРЕМЕННОЙ КЛАССА В ТОМ ЧТО КОНСТАНТА НЕ ИМЕЕТ ЗНАКА $
			Ссылаться на константы можно используя объект например MyClass::SUCCESS; 
			
			
			пример 
			
				<?php
				class MyClass {
					 const SUCCESS = "Success";
					 const FAILURE = "Failure";
				}
				print MyClass::SUCCESS;
				?> 
			
			--------------------------------------------------------------
			
			---------------------parent::     self::
			----------------------
			---------------------
			
			<?php
			class Person {
				public static $name='1';
			 
				function getName() {
					return self::$name;
				}
			}
			 
			class Person2 extends Person {
				public static $name='2';
			 
				function getName1() {
					return parent::$name;
				}
				function getName2() {
					return self::$name;
				}
			}
			 
			 
			$person = new Person2();
			print $person->getName1(); // выведет  1
			 
			 
			 
			$person = new Person2();
			print $person->getName1(); // выведет  2
			?>
			
			
			Т.е. в кратком и понятном виде на словах:
			parent - вызов метода родительского класса
			self - вызов метода текущего класса

			Удобно использовать когда в текущем классе и родительском переменные или константы с одним и тем же именем, но в текущем классе нужно использовать значение и одного и другого.
			
			
			
			-----------СТАТИЧЕСКИЕ МЕТОДЫ КЛАССА
			Статические МЕТОДЫ МОЖНО ВЫЗЫВАТЬ БЕЗ СОЗДАНИЯ ОБЪЕКТА КЛАССА.
			Вы можете теперь определить методы как статические, разрешая им быть вызванными вне контекста объекта.
			Статические методы не определяются через переменную $this, поскольку они не должны быть ограничены определенным объектом. 
			
			<?php
			class MyClass {
				 static function helloWorld() {
					 print "Hello, world";
				 }
			}
			MyClass::helloWorld();
			?> 
			
			------------АБСТРАКТНЫЕ КЛАССЫ	 abstract class test {}
			---------------------------------------------------
			---------------------------------------------------
			---------------------------------------------------
			PHP 5 поддерживает определение абстрактных классов и методов. Создавать экземпляр класса, который был объявлен абстрактным, нельзя.
			Класс, в котором объявлен хотя бы один абстрактный метод, должен также быть объявлен абстрактным.
			Методы, объявленные как абстрактные, несут, по существу, лишь описательный смысл и не могут включать какой-либо функционал. 
			Класс может быть объявлен как абстрактный при помощи использования ключевого слова abstract, для исключения из обработки движком описания класса.
			Однако, вы можете наследовать абстрактные классы. 
			
			<?php

				abstract class AbstractClass {

					/* Данный метод должен быть определён в дочернем классе */
					abstract protected function getValue();

					/* Общий метод */
					public function print() {
					  print $this->getValue();
					}

				}

				class ConcreteClass1 extends AbstractClass {

					protected function getValue() {
					  return "ConcreteClass1";
					}

				}

				class ConcreteClass2 extends AbstractClass {

					protected function getValue() {
					  return "ConcreteClass2";
					}

				}

				$class1 = new ConcreteClass1;
				$class1->print();

				$class2 = new ConcreteClass2;
				$class2->print();
				?>
				
				------АБСТРАКТНЫЕ МЕТОДЫ 
				
				Метод может быть объявлен как abstract, таким образом отложив его определение наследуемым классом.
				Класс, который включает абстрактные методы, должен быть объявлен как abstract. 
				
				<?php
				abstract class MyBaseClass {
					 abstract function display();
				}
				?> 
				
				-----ИТЕРАТОРЫ 
				PHP 5 предоставляет механизм итераторов для получения списка всех свойств какого-либо объекта, например, для использования совместно с оператором foreach.
				По умолчанию, в итерации будут участвовать все свойства, объявленные как public. Пример использования итераторов: 
				
				<?php

				class MyClass {
				   public $var1 = 'value 1';
				   public $var2 = 'value 2';
				   public $var3 = 'value 3';

				   protected $protected = 'protected';
				   private   $private   = 'private';

				}

				$class = new MyClass();

				foreach($class as $key => $value) {
				   print "$key => $value\n";
				}
				
				
				Результат
				
				var1 => value 1
				var2 => value 2
				var3 => value 3
				
				Как показывает результат, foreach проитерировал все принадлежащие объекту public-свойства.
				
				
				------------
				-----------
				----------------------------------------------
				ПОЛЕЗНАЯ ФУНКЦИЯ function __autoload(){} загружает класс как только мы его вызываем 
					-а функция __autoload должна быть подключена  с файлом в котором она находиться в файле в котором будем вызывать класс 
					
				function __autoload ($class) {            //используеться 2 подчеркивания подключаем файл отправки письма в фалйе class Mail
				$file = './class '.$class.'.php';      //после class пробел потому как название файла (пример) (class Mail.php) Mail название класса как только это слово пишем в месте где подключен файл с этой функцией загружаеться класс
				include_once($file);
				}
				
				$test = new Mail();
				
				
				------------------------------------------------
				------------------------------------------------
				------------------------------------------------Обработка исключительных ситуаций (исключений) try/throw/catch
				Исключения - это какие-либо аварийные ситуации, возникающие при выполнении скрипта. В PHP исключение можно сгенерировать ("выбросить", "вызвать") и поймать его.
				Исключение может сенерироваться как интерпретатором, так и разработчиком. 
				
				Вызов исключения производится следующим образом:
					<?php
						throw new Exception('My exception message');
					?>
				
				Перехват исключения осуществляется с помощью конструкции try...catch. В общем виде эта конструкция записывается так:
					<?php
						try
						{
							// код, который может выбросить исключение
						}
						catch(Exception $ex)
						{
							//$ex - экземпляр класса Exception
							// или его наследника
						}
					?>
				
				ИЛИ ВОТ РЕАЛЬНІЙ ПРИМЕР использования throw new Exception - Выведет информацию кторую мы написали о ошибке соединения с БД
				 self::$instance = new MySQLi(self::$_host, self::$_username, self::$_password, self::$_database);
				if(self::$instance->connect_error) { //if mysql (connect_error) display error
					throw new Exception('MySQL connection failed: ' . self::$instance->connect_error);//throw new exception ИСКЛЮЧЕНИЕ сробатывет если self::instance возвращает ошибку
				}
				
				Стоит отметить, что блоков catch может быть много, по одному на каждый класс перехватываемых исключений. 
				Таким образом можно создать фильтр исключений, т.е. перехватывать не все, а только избранные типы исключений, а все остальные будут перехвачены стандартным обработчиком PHP.
				
				
				
				Вам остается только создать объекты, которые наследуют класс исключений Exception. 
				
				В крупном приложении необходимо использовать свои собственные классы исключений (унаследованные от встроенного класса Exception)
				
			
				Это позволяет выстроить иерархию классов ошибок и разделять их по важности, типу и так далее. Допустим, у нас есть класс Application_Exception:
				
				ПРИМЕР СОЗДАНИЯ СВОИХ КЛАССОВ ИСКЛЮЧЕНИЙ -
				
				class Application_Exception extends Exception{...} и несколько его потомков:
				
				class Logic_Exception extends Application_Exception{...} -- логические ошибки, например, нарушение связности таблиц в БД или уникальности ключей.
				
				class Data_Access_Exception extends Application_Exception{...} -- ошибки доступа к необходимым данным, вроде отсутствия файла, или устройства, или связи для доступа к какому-то источнику.
				
				class Security_Exception extends Application_Exception{...} -- ошибки с безопасностью, например человек присылает куку, которой у него просто не может быть ;)
				
				--
				Для получения максимального количества информации об ошибке, используйте возможности встроенного класса Exception, 
				
				------------------------------------------------------------
				
				
				-------------------------------Инициализация и чтение значений полей класса при помощи __get()(Гетер) и __set()(Сетер) (магические методы)
				
				Тем не менее, PHP позволяет создавать “виртуальные” поля, которых на самом деле нет в классе, но к которым можно получить доступ через оператор ->.
				Они могут быть полезны в таких случаях:
				
					-Когда у вас очень много полей, и вы хотите создать для них массив, чтобы не объявлять каждое поле отдельно;
					-Когда вам нужно хранить поле за пределами объекта, например, в другом объекте, или даже в файле или базе данных;
					-Когда вам нужно вычислять значения полей “на лету”, а не хранить их значения где-либо.
					
				Чтобы создать такие “виртуальные” поля, нужно добавить в класс парочку волшебных методов:
				
					__get( $propName ) вызывается автоматически при попытке прочитать значение “невидимого” поля $propName;
					__set( $propName,$propValue ) вызывается автоматически при попытке задать “невидимому” полю $propName значение $propValue.
					
					“Невидимый” в данном контексте значит, что на данном участке кода нельзя прямо получить доступ к данным полям. 
					Например, если такого поля вообще нет в классе, или если оно существует, но оно частное, и за пределами класса нет доступа к такому полю.
				
				Перейдем к практике. Изменим наш класс Member так, чтобы в дополнение полю $username были еще и другие случайные поля, которые будут храниться в массиве $data:
				
					class Member {                                       //(1)В классе Member есть постоянное поле private $username и private массив $data для хранения случайных “виртуальных” полей;
						 private $username;
						 private $data = array();
						 public function __get( $property ) {        //(2)Метод __get() принимает единственный параметр $property - имя поля, значение которого нужно вернуть.
						   if ( $property == "username" ) {			//(3)Если $property = “username”, то метод вернет значение поля $username.
							 return $this->username;
						   } else {									//(4)В другом случае, метод проверит, встречается ли такой $property в ключах массива $data.
							 if ( array_key_exists( $property, $this->data ) ) {  //(5) Если найдется такой ключ, он вернет значение данного поля, в противном случае - null.
							   return $this->data[$property];					//(6) возвращаем сзачение данного поля
							 } else {
							   return null;
							 }
						   }
						 }
						 public function __set( $property, $value ) {  //(7)Метод __set() принимает 2 параметра: $property - имя поля, которое нужно инициализировать, и $value - значение, которое нужно задать данному полю.
						   if ( $property == "username" ) {			//(8)Если $property = “username”, метод инициализирует поле $username значением из параметра $value.
							 $this->username = $value;
						   } else {									//(9)В противном случае, добавляет в массив $data ключ $property со значением $value.
							 $this->data[$property] = $value;
						   }
						 }
					}
					$aMember = new Member();
					$aMember->username = "fred";					//(10)После создания класса Member, создаем объект этого класса и инициализируем его поле $username значением “fred”.
					//(11)Это вызывает метод __set(), который задаст значение $username объекту.
					$aMember->location = "San Francisco";			//Затем устанавливаем значение поля $location в “San Francisco” - Так как такого поля не существует в объекте, метод записывает его в массив $data.
					echo $aMember->username . "<br>";  // отобразит "fred"
					echo $aMember->location . "<br>";  // отобразит "San Francisco"
					//В конце, достаем значения $username и $location и выводим их на страницу. Метод __get() достает действительное значение $username из существующего поля $username, а значение $location - из массива $data.
					
					Как видите, с помощью методов __get() и __set() мы создали класс, в котором могут быть как настоящие поля, так и любые “виртуальные”. 
					Из фрагмента кода, где задается значение тому или иному полю, не обязательно знать, существует ли такое поле или нет в объекте. 
					Через обычный оператор -> можно задать полю значение или прочитать его.
					
					В примере также показано, как можно легко создать методы, называемые “геттерами” и “сеттерами”, для доступа к частным полям. 
					
					Если у вас уже были геттеры и сеттеры, все, что вам нужно, - это переписать их. А вызывающий код останется таким же. 
					Эта техника называется инкапсуляцией, и это одно из главных преимуществ ООП.
					
					
					
------------------------------------------------------------------Перегрузка методов с помощью __call() (это когда мы вызываем метод другого КЛАССА - а этот класс мы не наследовали)
					
					
					Геттеры и сеттеры используются для запрета на доступ к частным переменным. В этом же направлении используется метод __call() для запрета доступа к частным методам. 
					Как только из кода вызывается метод класса, который либо не существует, либо он недоступен, автоматически вызывается метод __call(). 
					Вот общий синтаксис метода:
					
						public function __call( $methodName, $arguments ) {
							// (действия)
						}
						
					Когда производится попытка вызвать недоступный метод класса, PHP автоматически вызывает метод __call(), в который передает строку - имя вызываемого метода и список передаваемых параметров в массиве.
					Затем ваш метод __call() должен будет определенным способом обработать вызов и, в случае необходимости, вернуть значения.
					
					Метод __call() полезен в ситуациях, когда вам нужно передать некую функциональность класса другому классу. 
					Вот простой пример:
					
					
						 У нас есть класс Member с полем $username и класс Topic с полем - объектом класса Member (автор статьи) и полем $subject - темой статьи. 
						 Класс Topic содержит метод getSubject() для получения темы статьи, но в нем нет метода, который возвращал бы имя автора статьи. 
						 Вместо него в нем есть метод __call(), который вызывает несуществующий метод и передает аргументы методу класса Member.
					
						class Member {
							 private $username;
							 public function __construct( $username ) {
							   $this->username = $username;
							 }
							 public function getUsername() {
							   return $this->username;
							 }
						}
						class Topic {
							 private $member;
							 private $subject;
							 public function __construct( $member, $subject ) {
							   $this->member = $member;
							   $this->subject = $subject;
							 }	 
							 public function getSubject() {
							   return $this->subject;
							 }
							 public function __call( $method, $arguments ) {
							   return $this->member->$method( $arguments );
							 }
						}
							$aMember = new Member( "fred" );
							$aTopic = new Topic( $aMember, "Hello everybody!" );
							echo $aTopic->getSubject() . "<br>"; // отобразит "Hello everybody!"
							echo $aTopic->getUsername() . "<br>"; // отобразит "fred"		//(1)Когда в коде вызывается метод $aTopic->getUsername(), PHP понимает, что такого метода в классе Topic не существует.
							//(2)Поэтому вызывается метод __call(), который в свою очередь, вызывает метод getUsername() класса Member. 
							//(3)Этот метод возвращает имя автора методу __call(), а тот отправляет полученное значение вызывающему коду.
							
					На заметку: в PHP есть и другие методы, касающиеся перегрузки, например, __isset(), __unset(), и __callStatic().
						
--------------------------------------------------------------Магический метод __toString() пример  (ИНТЕРПОЛЯЦИЯ ОБЪЕКТОВ)

		С помощью метода __toString() можно вывести информацию на экран которая пришла в класс с помошью return 
		Делаем echo на объект в который отправили данные и мы их увидем сразу на экране если в объекте используються __construct и __toString пример ниже
		
		ПРИМЕР :
		
		наш класс 
		
		class Test {
		public $_string;    //переменная в которую будем засовывать строку
		public $_tostring;  //переменная в которую будем засовывать строку

		public function __construct ($_string, $_tostring) {
			$this->_string = $_string;      //данные которые пришли в класс засовываем в переменную
			$this->_tostring = $_tostring;   //данные которые пришли в класс засовываем в переменную
		}

		public function __toString() {    //пример магического метода __toString()
			/* Метод "__toString()" выводит результат при использовании конструкции "return", а не "echo". */
			return "$this->_string - $this->_tostring";
		}

	}
	
		ВОТ ТАК ВЫВОДИМ ИНФОРМАЦИЮ которая придет в __construct c помощью __toString
		
		$my_string = new Test('Первое слово','Второе слово');
		echo $my_string;	//ВЫВЕДЕТЬСЯ 2 слова которые мы отправили в класс при создании объекта
		
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------



----------------------------------------------------------ИНТЕРФЕЙСЫ ОБЪЕКТОВ

				Интерфейсы объектов позволяют программисту создавать код, который указывает, какие методы и свойства должен включать класс, без необходимости описывания их функционала. 
				Интерфейсы объявляются так же, как и обычные классы, но с использованием ключевого слова "interface"; тела методов интерфейсов должны быть пустыми. 
				Для включения интерфейса в класс программист должен использовать ключевое слово "implements" и описать функционал методов, перечисленных во включаемом интерфейсе. 
				Если это требуется, классы могут включать более одного интерфейса путём их перечисления через пробел.
				
				Если класс включает какой-либо интерфейс и не описывает функционал всех методов этого интерфейса, выполнение кода с использованием такого класса завершится фатальной ошибкой, сообщающей, какие именно методы не были описаны. 
				
				Пример интерфейса: 
				
				
					<?php
					interface ITemplate
					{
					   public function setVariable($name, $var);
					   public function getHtml($template);
					}

					class Template implements ITemplate
					{
					   private $vars = array();
					  
					   public function setVariable($name, $var)
					   {
						 $this->vars[$name] = $var;
					   }
					  
					   public function getHtml($template)
					   {
						 foreach($this->vars as $name => $value) {
						   $template = str_replace('{'.$name.'}', $value, $template);
						 }
						
						 return $template;
					   }
					}
					?>
					
--------------------------------------------------------------------
---------------------------------------------------------------Оператор instanceof

			функция instanceof показывает принадлежит ли ОБЪЕКТ проверяемому классу или нет
			
			ПРИМЕР
			
				$GBinfo =new Guestbook;             //создаем объект класса что-бы обратиться г его методу
				$gbook_all=$GBinfo->select();       //вызываем метод класса который выводит все коментарии пользывателей ($gbook_all через цикл выводим в нужном блоке отзывов клиентов например)
				if ($GBinfo instanceof Guestbook) {
					echo 'Да';						//выводит ДА объект принадлежит проверяемому классу
				}
----------------------------------------------------------------------

------------------------------------------------------Метод final	
			Ключевое слово final позволяет вам помечать методы, чтобы наследующий класс не мог перегрузить их. Например наследуемый класс неможет (перезаписать ) метод класса родителя обозначенный как final
			Разместив перед объявлениями методов или свойств класса ключевое слово final, вы можете предотвратить их переопределение в дочерних классах, 
			
			например: 
			
				<?php
				class BaseClass {
					public function test() {
						echo "Вызван метод BaseClass::test()\n";
					}
				   
					final public function moreTesting() {
						echo "Вызван метод BaseClass::moreTesting()\n";
					}
				}

				class ChildClass extends BaseClass {
					public function moreTesting() {			//выводит ошибку потому как метод moreTesting обозначен как final в родительском классе и его нельзя переписать
						echo "Вызван метод ChildClass::moreTesting()\n";
					}
				}
				// Выполнение заканчивается фатальной ошибкой: 
				//Cannot override final method BaseClass::moreTesting()
				// (Метод BaseClass::moretesting() не может быть переопределён)
				?> 
										
		
				
-------------------------------------------------------
---------------------------------------------------Классы, помеченные как final
				После объявления класса final он не может быть унаследован. 
				
				Следующий пример вызовет ошибку: 
				
					<?php
					final class FinalClass {
					}

					class BogusClass extends FinalClass {
					}
					?> 
	
-------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------	
	
	
	
	
	
	
-----------------------НИЖЕ СТАРАЯ ШПОРГАЛКА О ООП
--Классы создаються так - ОДИН КЛАСС и ОДИН ФАЙЛ и как правило класс называют так что он делает
--ПОД ВСЕ Задачи или функции на сайте существуют свои КЛАССЫ
 КЛАСС Это своего рода объединение внутри себя функций и переменных ( тоесть в одной области видимости)
  И Вызывая класс мы обращаемся к разным функциям находящимся внутри кдасса или переменных
  
  self - используеться при статическом КЛАССЕ ( для доступа к статичному свойству)
  this - когда обращаемся к ЭКЗЕМПЛЯРУ кого нибуть КЛАССА
  
  
        пример
 
	<?php class myName1 {
		static $opacity = 100;      //static (это что-бы можно было ссылаться на содержание массива вот так (::))
		static $size = 30;
		
		static function makeLine1() {
			echo 'test_func';
		
		}
		static function makeLine2() {
		
		}
		static function makeLIine3() {
		
		}
	}
	echo myName1::$opacity;                 //вызываем класс и сылаемся на переменую внутри
	echo myName1::makeLine1 ($var,$var2);   //(любые значения можно передавать они у нас в функции не обозначены потму что)вызываем класс и функцию внутри него
	
	
		ФУНКЦИИ ДЕЛЯТЬСЯ НА 2 вида СТАТИЧНЫЕ (static, public,privat,protected) и НЕ СТАТИЧНЫЕ
		
		(public) - позволяет пользоваться несколькими действиями через один класс  (через обычные переменные)
		(privat) - выполняет одно действие  с классом, и свойствам класса которым присвоена функция privat работает только внутри класса
			-СТАТИЧНЫЕ - пример выше! (static) (видны из других функций и классов)
					  (тоесть у них глобальная зона видимости)
					  
					  Переменные которые храняться внутри КЛАССА называються свойствами
					  А функции внутри класа называються МЕТОДЫ
					  КЛАСС -Набор свойст и методов для реализации поставленной задачи
					  
					  
					  
			------Например напишем класс для навигации страниц - сколько страниц ф зоне видимости и т.д.
				(static))
		
						class paginator {
							static $hompages = 9;   //число страниц
							static $shownumber = true;
							static $shownext = true;
							static function showPaginator () {
								echo '1,2,3,4';
							}
						}
						paginator::showPaginator();   //так выводим просто
						
						
						
						class paginator {
							static $hompages = 9;   //число страниц
							static $shownumber = true;
							static $shownext = true;    //переменная показа следующей страници
							static function showPaginator () {
								return '1,2,3,4';            //вернуть значение
							}
						}
						$page = paginator::showPaginator();   //а так если нада в переменную поместить
							
						}
						-------------
						
						
						class paginator {
							static $hompages = 9;   
							static $shownumber = true;
							static $shownext = true;    
							static function showPaginator () {	
							$hompages = self::$hompages;    //self -говорит о том что мы сылаемся к определенному свойству внутри класса      
							if(self::$hompages ==5) {
								echo 'что-то свое';
							}
							echo '1,2,3,4';
							}
						}
						paginator::showPaginator();
						echo '<hr>';
						paginator::$hompages = 5;    //поменяем значение свойства (переменной) класса ( тогда условие IF выполняеться и появляеться надпись)
						paginator::showPaginator(); //и вызываем метод (функцию) внутри клаза что-бы проверить условие IF внутри него на выполнение
						
						
			-----------КЛАСС НА ПОДКЛЮЧЕНИЕ К БД НАПРИМЕР (Конфигурационный класс)

				class Database     //класс который создает один раз экземпляр класса (Что позволяет на использовать одно подключение к БД а не много что улучьшает работу сайта)
					{
						private static $_host = "localhost";
						private static $_username = "user";
						private static $_password = "11111";
						private static $_database = "bogdan";
						private static $instance; // stores the MySQLi instance (Сохраняем в этой переменной экземпляр класса Database который назвали MySQLi)
						private function __construct() { } // block directly instantiating
						private function __clone() { } // block cloning of the object
						/**
						 * @return MySQLi
						 * @throws Exception
						 */
						public static function connect () {
							// create the instance if it does not exist
							if(!isset(self::$instance)) {
								// the MYSQL_* constants should be set to or
								//  replaced with your db connection details
								self::$instance = new MySQLi(self::$_host, self::$_username, self::$_password, self::$_database);
								if(self::$instance->connect_error) {
									throw new Exception('MySQL connection failed: ' . self::$instance->connect_error);//throw new exception ИСКЛЮЧЕНИЕ сробатывет если self::instance возвращает ошибку
								}
							}
							return self::$instance;
						}
					}
				
				
				
			-------------	(public)  В данном случае класс работает внутри переменной и мы можем вызывать несколько действий через 1 класс используя разные переменные
				(public) - похволяет пользоваться несколькими действиями через одну функция  (через обычные переменные)
				
						<?php
							   class Illustrator {
								   public $radius = 10;

								   public function makeGraphic(){
										echo $this->radius;
									}
							   }
							$ill1 = new Illustrator();     //экземпляр КЛАСС (весь класс находиться в переменной $ill1 - и это не КОНСТАНТА а переменная 

							$ill2 = new Illustrator();     // присвоили переменной определенный класс 

							$ill1->radius = 5;              //одна переменная выведет одно значения другая другое но будут использывать 1 класс
							$ill2->radius = 33;

							echo $ill1->radius;
							echo '<hr>';
							echo $ill2->radius;
							
							
			---------еще пример 
			
						<?php
		   class Illustration {
			   public $radius = 10;
			   public function makeGraphic(){
				   $this->test();
					echo $this->radius;
				}
			   private function test (){   //закрыта от публичного доступа ( вне КЛАССА)

			   }
		   }
		$test = new Illustration;     //классу присвоили переменную
		$test->lala = 'Экспиримент';   // тут мы создаем новое свойство (переменной КЛАССА) $lala = 'Экспиримент' новое свойства (переменная с значением  'Экспиримент'
		echo '<pre>'.print_r($test,1).'</pre>';
				
				
				
		--------НЕ СТАТИЧНЫЕ КЛАССЫ











--------------------------------
------------------------------- ТИПАЖИ  - (Traits) 

	- это великолепное дополнение, появившееся в PHP 5.4, позволяющее добавлять классу поведение без необходимости расширения
	 родительского класса через наследование (до версии 5.4 это можно было реализовать с помощью паттерна примесь).

	ПРИМЕР:

trait Movement {
    public function topSpeed() {
        $this->speed = 100;
        echo "Running at 100 %!" . PHP_EOL;
    }
    public function stop() {
        $this->speed = 0;
        echo "Stopped moving!" . PHP_EOL;
    }
}

trait Speak {
    public function makeSound(){
        echo $this->sound . PHP_EOL; 
    }
}


Теперь воспользуемся ключевым словом use, но не для импорта пространства имён, а для включение типажей в определение класса:

class Dog {
    use Movement, Speak;  // теперь у класса Dog есть функционал из этих типажей
    protected $sound;
    
    function __construct() {
        $this->sound = 'bark';
    }
}

$dog = new Dog();
$dog->topSpeed();  // из типажа Movement
$dog->stop();      // из типажа Movement
$dog->makeSound(); // из типажа Speak

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
----------------ПРИМЕР ОТПРАВКИ ПИСЕМ Через Класс

<?php          //класс отправки Mail при регестрации

mail('кому','тема письма','текст письма'); // mail функция для отправки писем
mail('кому','тема письма','текст письма',$headers); //$headers заголовки которые нужно указать
 //письма можно отправялть 2-х типов
class Mail
{
    static $subject = 'По умолчанию';
    static $from = 'noreply@mydomain.ru'; //почта например Домена на котором наш сайт
    static $to = 'bogdan.dvinin@rambler.ru';
    static $text = 'Вы успешно заррегестрировались';
    static $headers = '';

    static function send(){
        self::$subject = '=?utf-8?b?'.base64_encode(self::$subject).'?='; //указываем что свойство (переменная класа) $subject будет использовать кодировку utf-8
        self::$headers = "Content-type: text/html; charset=\"utf-8\"\r\n"; //указали Content-type и charset
        self::$headers .="From: ".self::$from."\r\n";  //кто отправитель
        self::$headers .="MIME-Version: 1.0\r\n";      //версия письма
        self::$headers .="Date: ". date('D, d M Y h:i:s O')."\r\n"; //дата когда письмо было отправлено
        self::$headers .="Precedence: bulk\r\n";       //Precedence bulk говорит о том что рассылки отсылаються всем подрят
        return mail(self::$to, self::$subject, self::$text, self::$headers);   //mail отправляет письмо и возвращает true или false поэтому если return вернет значение true то письмо отправлено
        //mail возвращет true или false поэтому если вернет true значит письмо отправлено
    }

   /* static function testMail()    //функция тестовая если не будут отправляться письма то на англиском нада отправлять
    {
        if (mail(self::$to, 'English words', 'English words')) {
            echo 'письмо отправлено';
        } else {
            echo 'письмо не отправлено';
        }
        exit();
    }*/
}

Mail::$to = 'Oleg@ram.ru';
Mail::$subject = 'вы зарегестрировались';
Mail::$text = 'Наш текст';
Mail::send();               //письмо отправленно

//чтобы запустить проверку письма если она нада (вдруг письмо не отправляеться )
//Mail::testmail();

------------------------------------




-----------------------------Копирование объектов

<?php
class A {
// Создаем новый метод:
 function Test() {
 echo "<h1>Hello!</h1>";
 }
}
// Создаем объект класса A:
$a=new A();
// Копируем объект $a:
$b=$a;
// Теперь работаем с новым объектом $b
$b->Test(); // Выводит 'Hello!'
?>




---------------------------------Сравнение объектов

В PHP 4 объекты сравниваются очень просто: по именам. Два объекта равны, если они имеют те же самые свойства и значения, а также являются экземплярами одного и того же класса.
 Сравнение двух объектов осуществляют, используя оператор эквивалентности (===). Вот пример:
 
 
 <?php
class A {
// Создаем новый метод:
 function Test() {
 echo "<h1>Hello!</h1>";
 }
}

// Создаем объект класса A:
$a=new A();
// Создаем объект класса A:
$b=new A();
// Выводит 'Объекты равны':
if ($a===$b) echo "<h3>Объекты равны</h2>";
?>



-----------------------------------Ссылки на объект с помощью символа &


<?php
class A {
// Создаем новый метод:
 function Test() {
 echo "<h1>Hello!</h1>";
 }
}

// Создаем объект класса A:
$a=new A();
// Ссылка на объект класса A:
$b=& new A();
$b->Test();
?>







-----------------------------------------------------------------------GUESTBOOK
-----КЛАСС GuestBook мы не используем в примере мы его написали просто для наявного пример метода __construct
			ДАЛЕЕ создаем класс который соединяеться с нашей базой
			
			class DataBase {
				public $DB = 'localhost';
				public $DBLOGIN = 'user';
				public $DBPASS = '11111';
				public $DBNAME = 'bogdan';
				public function db_connect(){      //функция поключения к ДБ
					$connect = mysqli_connect($this->DB,$this->DBLOGIN,$this->DBPASS,$this->DBNAME) or die (mysqli_error());
					return $connect;
				}
			}
			Создаем класс который наследуеться из класса database что-бы использовать ее метод соединения с БД и который будет сохранять данные в БД и выводить
			class GuestBookDb extends DataBase{                   // GuestBookDb наследует все методы и переменные класса DataBase
				public function Select(){
				   // $connect=$this->db_connect();   //МЕТОД из НАСЛЕДУЕМОЙ ФУНКЦИИ DataBase (несет в себе пожключение в ДБ)
					$sql = mysqli_query($this->db_connect(),"SELECT name, email, msg FROM guestbook ORDER BY id DESC");
					while($rows = mysqli_fetch_assoc($sql)) {
						$gbook[]= $rows;
					}
					return $gbook; //возвращаем массив с запросом в БД
				}
				public function Insert($name,$email,$msg){
				   $query = mysqli_query($this->db_connect(),"INSERT INTO guestbook (name, email, msg) VALUES('$name', '$email', '$msg')");
						if($query === TRUE){
							echo 'ok';
							return TRUE;
						}else{
							echo 'ошибка';
							return FALSE;
						}
				}
			}
			
		
			НАСЛЕДИЕ Extends -  Под наследованием понимается расширение старого класса до нового путём расширения функциональности, т.е. новый класс будет содержать те же методы (которые, кстати, могут и изменить свою реализацию) и свойства прежнего класса.
			Новый класс мы называем классом-потомком, а прежний, от которого происходит наследование, классом-предком или базовым классом. 
			Наследование используется, в первую очередь, для построения иерархических систем, в котором классы-потомки развивают функциональность базовых классов.
			Наследование также может использоваться для изменения логики первоначальной реализации - т.е. для модификации уже существующего приложения.
			-----
						
			НАСЛЕДОВАНИЕ КЛАССА – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.
			Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.
			
			Необходимо отметить, что производный класс полностью удовлетворяет спецификации родительского, однако может иметь дополнительную функциональность.
			С точки зрения интерфейсов, каждый производный класс полностью реализует интерфейс родительского класса. Обратное не верно.
			----
			
			Вот как выглядит файл оработки формы и в нем вызываем классы класс сохранены в файле config.php
			
			include_once "./config.php"; //файл с классами
				if (isset($_POST['submit'])){
					//echo $_POST['email'].' '.$_POST['name'].' '.$_POST['msg'];
					$name = $_POST['name'];
					$email = $_POST['email'];
					$msg = $_POST['msg'];
					$gbook = new GuestBookDb();          //создаем объект класса
					$gbook ->Insert($name,$email,$msg);  //передаем в метод класса параметры для сохранения в БД
				}
			
			Далее выводит данные из бд в главном файле таким образом
			
			include_once "./libs.php"; //файл обработки формы
			include_once "./config.php"; //файл с библиоотекой классов
			$GBinfo = new GuestBookDb(); //создаем объект класса что-бы обратиться г его методу
			$gbook_all=$GBinfo->select();  //вызываем метод класса который выводит все коментарии пользывателей ($gbook_all через цикл выводим в нужном блоке отзывов клиентов например)
			
			$bgook_all - это массив который содержит информацию из БД и через foreach мы выводим данные на экране
			
---------------------------------------------------------------END OF Gbook class
---------------------------------------------------------------------------------------------------------------------------








-------------------------------МАГИЧЕСКИЕ МЕТОДЫ 

1) Пример использования __get __set  

__set - кладет значение в переменную
__get - возвращаем значение из переменной

class MyClass {
    private $firstField;
    private $secondField;
    public function __get($property) {
        if (property_exists($this, $property)) {
            return $this->$property;
        }
    }
    public function __set($property, $value) {
        if (property_exists($this, $property)) {
            $this->$property = $value;
        }
    }
}
$myClass = new MyClass();
$myClass->firstField = "This is a foo line";
$myClass->secondField = "This is a bar line";
echo $myClass->firstField;
echo '<br>';
echo $myClass->secondField;